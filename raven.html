<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Raven — Grid</title>
<style>
  :root {
    --bg: #000;
    --tile: #222;
    --label: #ddd;
    --gap: 6px;
  }
  html,body { height:100%; margin:0; font-family: Inter, Arial, Helvetica, sans-serif; background:var(--bg); color:var(--label); }
  .wrap { display:flex; align-items:center; justify-content:center; height:100%; padding:18px; box-sizing:border-box; }
  .panel { width:640px; max-width:95vw; background:rgba(255,255,255,0.03); padding:16px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,.6); }
  .title { text-align:center; margin-bottom:8px; color:#ccc; font-weight:600; }
  canvas { width:100%; height:auto; display:block; background:transparent; border-radius:6px; }
  .footer { font-size:12px; color:#bbb; text-align:right; margin-top:8px; }
  .controls { margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
  .controls select, .controls input { padding:6px 8px; background:#111; color:#ddd; border:1px solid #222; border-radius:6px; }
  .controls button { padding:6px 10px; background:#1b6; color:#030; border:none; border-radius:6px; cursor:pointer; }
  .note { color:#888; font-size:12px; margin-top:6px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <div class="title">Raven — Map (A–E / 1–5)</div>
    <canvas id="mapCanvas" width="540" height="540" aria-label="Raven map"></canvas>

    <div class="controls">
      <label>Row:
        <select id="selRow">
          <option>A</option><option>B</option><option>C</option><option>D</option><option>E</option>
        </select>
      </label>
      <label>Col:
        <select id="selCol">
          <option>1</option><option>2</option><option>3</option><option>4</option><option>5</option>
        </select>
      </label>

      <label>OffsetX (0..1): <input id="offX" type="number" min="0" max="1" step="0.01" value="0.5" style="width:68px" /></label>
      <label>OffsetY (0..1): <input id="offY" type="number" min="0" max="1" step="0.01" value="0.5" style="width:68px" /></label>

      <button id="sendTest">Send Test</button>
      <div style="flex:1"></div>
      <div style="color:#aaa;font-size:12px">Made by Lonloy</div>
    </div>

    <div class="note">This page only visualizes events you explicitly send (via postMessage or a local WebSocket). It contains no game-intercepting or stealth code.</div>
    <div class="footer"></div>
  </div>
</div>

<script>
/*
  raven.html
  - Accepts messages in either form:
    { row: "A", col: 3, offsetX: 0.2, offsetY: 0.7 }  // offsetX/Y optional 0..1 inside tile (0 left/top, 1 right/bottom)
  OR
    { normX: 0.5, normY: 0.4 } // normalized coords across entire 5x5 grid (0..1)
  OR
    { x: <canvas px>, y: <canvas px> } // direct canvas pixels

  - Each dot is white, lasts DOT_TTL ms.
  - Grid mapping: top row = A, leftmost col = 1
*/

const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

const ROWS = 5, COLS = 5;
const DOT_TTL = 10000; // 10s
const DOT_RADIUS = 8; // px
const PADDING = 20; // px around the grid for labels
const GAP = 6; // gap between cells in px (visual)
const LABEL_FONT = 'bold 14px Arial';
const LABEL_COLOR = '#ccc';
const GRID_BG = '#111';
const CELL_BG = '#222';
const LINE_COLOR = '#333';

// store active dots as {x,y,expires}
let dots = [];

// normalize for high-dpi displays:
function resizeCanvasToDisplaySize() {
  const ratio = window.devicePixelRatio || 1;
  const cssW = canvas.clientWidth || canvas.width;
  const cssH = canvas.clientHeight || canvas.height;
  if (canvas.width !== Math.floor(cssW * ratio) || canvas.height !== Math.floor(cssH * ratio)) {
    canvas.width = Math.floor(cssW * ratio);
    canvas.height = Math.floor(cssH * ratio);
    ctx.setTransform(ratio,0,0,ratio,0,0);
  }
}
function getGridLayout() {
  // compute grid cell size based on canvas actual css width (no DPR)
  const w = canvas.clientWidth || canvas.width;
  const h = canvas.clientHeight || canvas.height;
  // available area inside padding
  const availW = w - PADDING*2 - (COLS-1)*GAP;
  const availH = h - PADDING*2 - (ROWS-1)*GAP;
  const cellW = Math.floor(availW / COLS);
  const cellH = Math.floor(availH / ROWS);
  const gridW = cellW * COLS + (COLS-1)*GAP;
  const gridH = cellH * ROWS + (ROWS-1)*GAP;
  const left = (w - gridW)/2;
  const top = (h - gridH)/2;
  return { w, h, cellW, cellH, gridW, gridH, left, top };
}

// draw static grid and labels
function drawBase() {
  resizeCanvasToDisplaySize();
  ctx.fillStyle = GRID_BG;
  ctx.fillRect(0,0,canvas.clientWidth, canvas.clientHeight);

  const L = getGridLayout();
  // draw cells
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const x = L.left + c*(L.cellW + GAP);
      const y = L.top + r*(L.cellH + GAP);
      ctx.fillStyle = CELL_BG;
      roundRect(ctx, x, y, L.cellW, L.cellH, 8);
      ctx.fill();

      // draw tile label (small, optional)
      ctx.fillStyle = '#777';
      ctx.font = '600 12px Arial';
      //ctx.fillText(String.fromCharCode(65+r) + (c+1), x + 8, y + 18);
    }
  }

  // draw grid thin lines
  ctx.strokeStyle = LINE_COLOR;
  ctx.lineWidth = 1;
  for(let r=0;r<=ROWS;r++){
    const y = L.top + r*(L.cellH + GAP) - (r===ROWS? -GAP : 0);
    // horizontal lines: draw between cells
  }
  // labels top (1..5)
  ctx.fillStyle = LABEL_COLOR;
  ctx.font = LABEL_FONT;
  for(let c=0;c<COLS;c++){
    const x = L.left + c*(L.cellW + GAP) + L.cellW/2;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.fillText(String(c+1), x, L.top - 6);
  }
  // labels left (A..E)
  for(let r=0;r<ROWS;r++){
    const y = L.top + r*(L.cellH + GAP) + L.cellH/2;
    ctx.textAlign = 'right';
    ctx.textBaseline = 'middle';
    ctx.fillText(String.fromCharCode(65+r), L.left - 10, y);
  }
}

// helper: rounded rect
function roundRect(ctx, x, y, w, h, r) {
  const rad = Math.min(r, h/2, w/2);
  ctx.beginPath();
  ctx.moveTo(x+rad, y);
  ctx.arcTo(x+w, y, x+w, y+h, rad);
  ctx.arcTo(x+w, y+h, x, y+h, rad);
  ctx.arcTo(x, y+h, x, y, rad);
  ctx.arcTo(x, y, x+w, y, rad);
  ctx.closePath();
}

function tileToCellCenter(rowChar, colNum) {
  const row = String(rowChar||'A').toUpperCase().charCodeAt(0) - 65; // 0..4
  const col = Number(colNum) - 1; // 0..4
  const L = getGridLayout();
  const x = L.left + col*(L.cellW + GAP) + L.cellW/2;
  const y = L.top + row*(L.cellH + GAP) + L.cellH/2;
  return { x, y, cellW: L.cellW, cellH: L.cellH, left: L.left, top: L.top };
}
function tileTopLeft(rowChar, colNum){
  const row = String(rowChar||'A').toUpperCase().charCodeAt(0) - 65;
  const col = Number(colNum) - 1;
  const L = getGridLayout();
  const x = L.left + col*(L.cellW + GAP);
  const y = L.top + row*(L.cellH + GAP);
  return { x, y, cellW: L.cellW, cellH: L.cellH };
}

function addDotAtCanvas(x,y) {
  const expires = Date.now() + DOT_TTL;
  dots.push({ x, y, expires });
}
function addDotAtTile(row, col, offsetX=0.5, offsetY=0.5) {
  const t = tileToCellCenter(row, col);
  const topLeft = tileTopLeft(row,col);
  const x = topLeft.x + Math.max(0, Math.min(1, offsetX)) * t.cellW;
  const y = topLeft.y + Math.max(0, Math.min(1, offsetY)) * t.cellH;
  addDotAtCanvas(x,y);
}

// handle incoming messages (postMessage or websocket JSON)
function handleIncoming(msg) {
  if (!msg) return;
  // accept {row,col,offsetX,offsetY}
  if (msg.row && msg.col) {
    addDotAtTile(msg.row, msg.col, msg.offsetX ?? 0.5, msg.offsetY ?? 0.5);
    return;
  }
  // accept normalized coords {normX, normY} 0..1 over whole grid
  if (typeof msg.normX === 'number' && typeof msg.normY === 'number') {
    const L = getGridLayout();
    const x = L.left + Math.max(0, Math.min(1,msg.normX)) * L.gridW;
    const y = L.top  + Math.max(0, Math.min(1,msg.normY)) * L.gridH;
    addDotAtCanvas(x,y);
    return;
  }
  // accept direct canvas pixel coords {x,y}
  if (typeof msg.x === 'number' && typeof msg.y === 'number') {
    addDotAtCanvas(msg.x, msg.y);
  }
}

// animation loop: redraw base + dots
function render() {
  resizeCanvasToDisplaySize();
  // clear
  ctx.clearRect(0,0,canvas.clientWidth, canvas.clientHeight);
  drawBase();

  // draw dots
  const now = Date.now();
  dots = dots.filter(d => d.expires > now);
  for(const d of dots) {
    // fade near expiry
    const t = 1 - (d.expires - now)/DOT_TTL;
    const alpha = 1 - Math.min(0.9, t); // fade slightly
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${alpha})`;
    ctx.arc(d.x, d.y, DOT_RADIUS, 0, Math.PI*2);
    ctx.fill();
    // optional small halo
    ctx.beginPath();
    ctx.fillStyle = `rgba(255,255,255,${alpha*0.12})`;
    ctx.arc(d.x, d.y, DOT_RADIUS*2.6, 0, Math.PI*2);
    ctx.fill();
  }
  requestAnimationFrame(render);
}
requestAnimationFrame(render);

// listen for postMessage
window.addEventListener('message', ev => {
  try {
    const d = ev.data;
    handleIncoming(d);
  } catch (e) {
    // ignore
  }
}, false);

// optional: local websocket (connects only to ws://localhost:8080)
let ws;
function tryConnectWs() {
  try {
    ws = new WebSocket('ws://localhost:8080');
    ws.addEventListener('open', () => console.log('Raven: connected to ws://localhost:8080'));
    ws.addEventListener('message', e => {
      try {
        const data = typeof e.data === 'string' ? JSON.parse(e.data) : JSON.parse(new TextDecoder().decode(e.data));
        handleIncoming(data);
      } catch (err) { /* ignore */ }
    });
    ws.addEventListener('error', () => { /* ignore */ });
    ws.addEventListener('close', () => { setTimeout(tryConnectWs, 2000); });
  } catch (err) { /* ignore */ }
}
// uncomment next line if you run a local test server
// tryConnectWs();

// small UI: send test
document.getElementById('sendTest').addEventListener('click', ()=>{
  const row = document.getElementById('selRow').value;
  const col = document.getElementById('selCol').value;
  const offX = parseFloat(document.getElementById('offX').value) || 0.5;
  const offY = parseFloat(document.getElementById('offY').value) || 0.5;
  // postMessage to same window (will be handled)
  window.postMessage({ row, col: Number(col), offsetX: offX, offsetY: offY }, '*');
});

</script>
</body>
</html>
